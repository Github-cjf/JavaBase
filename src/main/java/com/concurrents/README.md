# Java并发
> 主要知识来源 Java程序员修炼之道

## 理论知识
`线程模型`
- 共享的，默认可见的可变状态
- 抢占式线程调度

`concurrent包的设计理念`
- 安全性 （并发类型安全性）
    - 并发类型安全：不管发生多少操作都能保证对象保持自相一致。一般采用的是将所有属性私有化
- 活跃度
    - 在一个活跃的系统中，所有做出尝试的活动最终或者取得进展，或者失败
    - 可能出现瞬时故障的情况：
        - 处于锁定状态，或者在等待得到线程锁
        - 等待输入
        - 资源的暂时故障
        - CPU没有足够的空闲时间运行该线程 
    - 永久故障的常见原因：
        - 死锁
        - 不可恢复的资源问题（例如 NFS不可访问）
        - 信号丢失
- 性能
    - 测量系统用给定的资源能做多少工作
- 可重用性

*******
`可能的问题`
- 安全性与活跃度相对立，安全性求稳定安全，活跃度是求进展
- 可重用的系统倾向于对外开放内核，这会引发安全问题
- 一个安全但是编写幼稚的系统性能通常不会好，因为里面会用大量的锁来保证安全

`好的习惯`
- 尽可能限制子系统之间的通信，隐藏数据堆安全性非常有帮助
- 尽可能保证子系统内部结构的确定性，比如：即便子系统会以并发的，非确定性的方式进行交互，子系统内部的设计也应该按照线程和对象的静态知识
- 采用客户端应用必须遵守的方正。这个技巧虽然强大，但是依赖于用户应用程序的合作程度，如果某个糟糕的应用不遵守规则，排查问题很困难
- 在文档中记录所要求的行为，这是最逊的方法，但如果代码要部署在非常通用的环境下，就必须采用这个方法

***********
- 系统开销之源
    - 锁与监测
    - 环境切换的次数
    - 线程的个数
    - 调度
    - 内存的局部性
    - 算法设计
    
### 块结构并发 Java5之前
- 同步和锁 synchronized：
    - 只能锁定对象，不能锁定原始类型
    - 被锁定的兑现给数组中的单个对象不会被锁定
    - 同步方法可以视为包含整个方法的同步 (this){...}代码块 但是两者的二进制码的表示是不同的
    - 静态方法会锁定其Class对象，因为没有实例对象可以锁定
    - 如果要锁定一个对象，请慎重考虑使用显式锁定，还是getClass()， 两种方式对子类影响不同
    - 内部类的同步是独立于外部类的
    - synchronized 并不是方法签名的组成部分，所以不能出现在接口的方法声明中
    - 非同步的方法不查看或关心任何锁的状态，而且在同步方法运行时，他们仍能继续运行
    - Java的线程锁是可重入的。也就是说持有线程锁的线程在遇到同一个锁的同步点 时是可以继续的
        - 比如 一个同步方法调用另一个类的另一个同步方法
      

![线程状态模型](https://raw.githubusercontent.com/Kuangcp/ImageRepos/master/Tech/Java/concurrent/Model.jpg)  
- 线程的状态模型：
    - 线程创建时处于准备（Ready）状态，然后调度器会准备执行
    
- 完全同步对象 策略
    - 一个满足下面所有条件的类就是完全同步类：
    - 所有域在任何公共构造方法中的初始化都能达到一致的状态
    - 没有公共域
    - 从任何非私有方法返回后，都可以保证对象实例处于一致的状态  假定调用方法时状态是一致的
    - 所有方法经证明都可在有限时间内终止
    - 所有方法都是同步的
    - 当处于非一致的状态时，不会调用其他实例的方法，以及调用非私有方法
  
*************
  
- synchronized：
     - 在synchronized代码块执行完成后，对锁定对象所做的所有修改全部会在线程释放之前同步到内存中
     - 所以这个关键字的作用就是同步 在不同线程中被锁定（操作）的对象的内存块
    
- volatile：
    - 线程所读的值在使用之前总会从内存中读出来
    - 线程所写的值总会在指令完成之前同步回内存中
        - 可以把围绕该域的操作看成成是一个小的同步块
        - volatile 变量不会引入线程锁，所以不可能发生死锁
        - volatile变量是真正线程安全的，但只有写入时不依赖当前状态（读取的状态）的变量才应该声明为volatile变量

- 不可变性：
    - 这些对象或者没有状态（属性）或者只有final域。因为他们的状态不可变，所以是安全而又活泼，不会出现不一致的情况
    - 初始化就会遇上问题，如果是需要初始化很多属性，可以采用工厂模式，但是构建器模式更好。
        - 一个是实现了构建器泛型接口的内部静态类，另一个是构建不可变类实例的私有构造方法 
        - [思想实现代码](./src/main/java/com/concurrents/old/BuildFactory.java)
    - 不可变对象中的final域特别要注意：
        - final声明的对象的引用是不可变的， 但是如果引用的是对象，该对象自身的属性的引用是可变的
    - 不可变对象的使用十分广泛，但是开发效率不行，每修改对象的状态都要构建一个新对象
    
### 现代并发 concurrent包

#### 原子类 java.util.concurrent.atomic
> 提供适当的原子方法 避免在共享数据上出现竞争危害的方法

- 常见的操作系统的支持， 他们是非阻塞的（无需线程锁）， 常见的方法是实现序列号机制（和数据库里的序列号机制类似），在AtomicInteger或AtomicLong上用原子
    - 操作getAndIncrement()方法， 并且提供了nextId 方法得到唯一的完全增长的数值
- 注意： 原子类不是相似的类继承而来，所以 AtomicBoolean不能当Boolean用

#### 线程锁 java.util.concurrent.locks
- 块结构同步方式基于锁这样的的概念，具有缺点
    - 锁只有一种类型
    - 对被锁住的对象的所有同步操作都是一样的作用
    - 在同步代码块或方法开始时取得线程锁
    - 在同步代码块或方法结束时释放线程锁
    - 线程或者得到锁，或者阻塞，没有其他可能
    
- 如果要重构对线程锁的支持， 事实上该包下Lock接口也都实现了：
    - 添加不同类型的锁，例如 读取锁和写入锁
    - 对锁的阻塞没有限制，允许在一个方法中加锁，另一个方法中解锁
    - 如果线程得不到锁（例如已经被线程加锁），就允许该线程后退或者继续执行，或者做别的事情 tryLock()
    - 允许线程尝试锁，并可以在超过时间后放弃
    - Lock接口的实现类：ReentrantLock 本质上和用在同步块上的锁是一样的，但是稍微灵活些
        - lock 方法：[官方API1.8 lock](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html#lock--)
        - 如果该锁没有被另一个线程保持，则获取该锁并立即返回，将锁的保持计数设置为 1。
        - 如果当前线程已经保持该锁，则将保持计数加 1，并且该方法立即返回。
        - 如果该锁被另一个线程保持，则出于线程调度的目的，禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态，此时锁保持计数被设置为 1。
        - trylock方法 [官方API1.8 trylock](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html#tryLock--)
    - Lock接口的实现类：ReentrantWriteLock 在需要读取很多线程而写入很少线程时，用这个性能更好
    
#### CountDownLatch 锁存器
- 是一种简单的同步模式，这种模式允许线程在通过同步屏障之前做少量的准备工作
    - 构建实例时，需要提供一个数值（计数器），通过两个方法来实现这个机制
    - countDown() await() 前者计数器减一，后者让线程在计数器到0之前一直等待， 如果已经是小于等于0 就什么都不做
- 就是一堆线程之间的同步，为了确保有指定数量正常初始化的线程 创建成功，才能开始同步

#### ConcurrentHashMap
- ConcurrentHashMap 是 HashMap的并发版本
- 修改HashMap，并不需要将整个结构都锁住，只要锁住即将修改的桶（就是单个元素）
    - 好的HashMap 实现，在读取时不需要锁，写入时只要锁住要修改的单个桶 Java能达到这个标准，但是需要程序员去操作底层的细节才能实现
- ConcurrentHashMap类 还实现了ConcurrentMap接口，有些提供了还提供了原子操作的新方法
    - putIfAbsent() 如果还没有对应键，就把键/值添加进去
    - remove() 如果键存在而且值与当前状态相等，则用原子方式移除键值对
    - replace() API 为HashMap中原子替换的操作方法提供了两种不同的形式
- 例如之前的完全同步类里的公共 Map实现就是HashMap，如果换成ConcurrentHashMap 那些synchronized关键字修饰的方法就可以换成普通方法了
- 该类不仅提供了多线程的安全性，性能也很好

#### CopyOnWriteArrayList
- 标准的ArrayList的替代，通过写时复制语义来实现线程安全性，也就是说修改列表的任何操作都会创建一个列表底层数组的新副本
    - 这就意味着所有成形的迭代器都不会遇到意料之外的修改 （脏读）
    
- 这一般需要很大的开销，但是当遍历操作的数量大大超过可变操作的数量时，这种方法可能比其他替代方法更 有效。在不能或不想进行同步遍历，
- 但又需要从并发线程中排除冲突时，它也很有用。“快照”风格的迭代器方法在创建迭代器时使用了对数组状态的引用。此数组在迭代器的生存期内不会更改，
- 因此不可能发生冲突，并且迭代器保证不会抛出 ConcurrentModificationException。创建迭代器以后，迭代器就不会反映列表的添加、移除或者更改。
- 在迭代器上进行的元素更改操作（remove、set 和 add）不受支持。这些方法将抛出 UnsupportedOperationException。

### Queue